% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runner_glmnet.R
\name{make_glmnet_runner}
\alias{make_glmnet_runner}
\title{Create a glmnet runner for discrete-time hazard modeling}
\usage{
make_glmnet_runner(
  rhs_list,
  alpha_grid,
  lambda_grid,
  use_weights_col = TRUE,
  standardize = TRUE,
  intercept = TRUE,
  strip_fit = TRUE
)
}
\arguments{
\item{rhs_list}{A list of RHS specifications, either:
\itemize{
  \item one-sided formulas such as \code{~ W1 + ns(bin_id, df = 5)}, or
  \item character strings such as \code{"W1 + splines::ns(bin_id, df = 5)"}.
}
These RHS are used to construct \code{in_bin ~ <rhs>} internally.}

\item{alpha_grid}{Numeric vector of elastic net mixing parameters passed to
\code{glmnet::glmnet(alpha = ...)}. Typical values lie in \code{[0, 1]}, where
\code{alpha = 1} corresponds to the lasso and \code{alpha = 0} to ridge
regression.}

\item{lambda_grid}{Numeric vector of strictly positive penalty values.
This grid is treated as fixed and is reused across folds and grid settings
to ensure tuning alignment. Must have length at least 2. Users should verify
that the grid passed in is diverse enough. If tuning parameters at the edge
of the grid are being selected by CV, then it could be an indication that a 
broader grid is required.}

\item{use_weights_col}{Logical. If \code{TRUE} and the training data contain a
column named \code{wts}, it is passed as \code{weights = ...} to
\code{glmnet::glmnet()}. Otherwise, fitting is unweighted.}

\item{standardize}{Logical. Passed directly to \code{glmnet::glmnet(standardize = ...)}.}

\item{intercept}{Logical. Passed directly to \code{glmnet::glmnet(intercept = ...)}.}

\item{strip_fit}{Logical. If \code{TRUE} (default), store a lightweight fit
representation (intercept and coefficient matrix only) rather than the full
\code{glmnet} object.}
}
\value{
A named list (runner) with elements:
\describe{
  \item{method}{Character string \code{"glmnet"}.}
  \item{tune_grid}{Data frame with columns \code{.tune}, \code{rhs},
        \code{alpha}, and \code{lambda}.}
  \item{fit}{Function \code{fit(train_set, ...)} returning a fit bundle.}
  \item{predict}{Function \code{predict(fit_bundle, newdata, ...)} returning
        an \code{n_long x K} matrix of hazard predictions.}
  \item{fit_one}{Function \code{fit_one(train_set, tune, ...)} fitting only
        the selected tuning index.}
}
}
\description{
Constructs a **runner** (learner adapter) compatible with the
\code{run_grid_setting()} / \code{summarize_and_select()} workflow used in
dsl_densify. The runner fits penalized logistic regression models via
\code{glmnet::glmnet()} on long-format discrete-time hazard data
(binary outcome \code{in_bin}), and supports a tuning grid over:
\itemize{
  \item multiple RHS model specifications (\code{rhs_list}),
  \item elastic net mixing parameters (\code{alpha_grid}),
  \item a fixed penalty grid (\code{lambda_grid}).
}

This runner supports natural spline terms specified directly in the RHS
formulas using \code{ns()} or \code{splines::ns()}, under a restricted but
relatively robust spline policy:
\itemize{
  \item Only \code{ns(<symbol>, df = ...)} is supported (the first argument must
        be a bare variable name, i.e., not \code{ns(log(variable))}).
  \item \code{splines::ns()} is accepted but internally is rewritten to \code{ns()}.
  \item Knot locations are computed on the training data and then frozen for
        prediction by evaluating \code{model.matrix()} in an environment where
        \code{ns()} is replaced by a wrapper that injects the stored knots and
        boundary knots. This ensures reproducible behavior across training and 
        validation folds
}
}
\details{
## Data requirements
The runner expects \code{train_set} and \code{newdata} in the **long hazard
format** produced by \code{format_long_hazards()}, including:
\itemize{
  \item a binary outcome column \code{in_bin},
  \item covariates referenced in \code{rhs_list},
  \item an optional \code{wts} column of observation weights.
}

## Spline handling
Spline knots are computed once per fold (inside \code{fit()}) using the
training data and stored in \code{design_specs}. Prediction uses the stored
knots to ensure consistent spline bases across training and validation data
within each fold.

## Interactions
Interactions between spline terms and other covariates (for example,
\code{W1 * ns(bin_id, df = 5)}) are supported and handled via
\code{model.matrix()}. Nested spline constructs are not supported.
}
\section{Numeric-only requirement}{

The design matrix is constructed using \code{stats::model.matrix()}.
To ensure stable feature definitions across folds and avoid factor-level
bookkeeping, this runner is intended for use with **numeric predictors only**
(including \code{bin_id} and all covariates in \code{W}). RHS formulas should
not include factors, characters, or ordered factors. This function does not
coerce variables to numeric; it assumes inputs are already in numeric form.
}

\section{Tuning grid and prediction layout}{

The internal \code{tune_grid} is ordered such that:
\itemize{
  \item RHS varies first,
  \item then \code{alpha},
  \item then \code{lambda}.
}
During cross-validation, \code{predict()} returns an
\code{n_long x K} matrix of predicted hazards, where
\code{K = length(rhs_list) * length(alpha_grid) * length(lambda_grid)},
with columns aligned to \code{tune_grid}.
}

\section{Lightweight fit objects}{

When \code{strip_fit = TRUE}, each fitted \code{(rhs, alpha)} block is reduced
to a minimal representation sufficient for prediction:
\itemize{
  \item an intercept vector \code{a0} of length \code{length(lambda_grid)},
  \item a sparse coefficient matrix \code{beta}
        (\code{Matrix::dgCMatrix}, dimensions \code{p x L}),
  \item the training column names \code{x_cols}.
}
This saves memory relative to storing full \code{glmnet} fits
}

\examples{
rhs_list <- list(
  ~ W1 + W2 + splines::ns(bin_id, df = 4),
  ~ (W1 + W2) * splines::ns(bin_id, df = 4)
)

runner <- make_glmnet_runner(
  rhs_list = rhs_list,
  alpha_grid = c(0.5, 1),
  lambda_grid = exp(seq(log(1e-4), log(10), length.out = 50)),
  strip_fit = TRUE
)

}

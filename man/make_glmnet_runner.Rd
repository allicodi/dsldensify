% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runner_glmnet.R
\name{make_glmnet_runner}
\alias{make_glmnet_runner}
\title{Create a glmnet runner for discrete-time hazard modeling}
\usage{
make_glmnet_runner(
  rhs_list,
  alpha_grid,
  lambda_grid,
  use_weights_col = TRUE,
  standardize = TRUE,
  intercept = TRUE,
  strip_fit = TRUE,
  ...
)
}
\arguments{
\item{rhs_list}{A list of RHS specifications, either as one-sided formulas
(for example, ~ W1 + ns(bin_id, df = 5)) or as character strings
(for example, "W1 + splines::ns(bin_id, df = 5)").}

\item{alpha_grid}{Numeric vector of elastic net mixing parameters passed to
glmnet::glmnet(alpha = ...). Typical values lie in [0, 1], where alpha = 1
corresponds to the lasso and alpha = 0 to ridge regression.}

\item{lambda_grid}{Numeric vector of strictly positive penalty values.
This grid is treated as fixed and reused across folds and grid settings
to ensure tuning alignment. Must have length at least 2.}

\item{use_weights_col}{Logical. If TRUE and the training data contain a
column named wts, it is passed as case weights to glmnet::glmnet().}

\item{standardize}{Logical. Passed to glmnet::glmnet(standardize = ...).}

\item{intercept}{Logical. Passed to glmnet::glmnet(intercept = ...).}

\item{strip_fit}{Logical. If TRUE (default), store a lightweight
coefficient-based representation of each fitted model.}

\item{...}{Additional arguments forwarded to glmnet::glmnet().}
}
\value{
A named list (runner) with the following elements:
  method: Character string "glmnet".
  tune_grid: Data frame describing the tuning grid, including .tune, rhs,
    alpha, and lambda.
  fit: Function fit(train_set, ...) returning a fit bundle.
  predict: Function predict(fit_bundle, newdata, ...) returning an
    n_long x K matrix of predicted hazards.
  fit_one: Function fit_one(train_set, tune, ...) fitting only the selected
    tuning index.
  select_fit: Function select_fit(fit_bundle, tune) returning a reduced
    fit bundle for a single tuning index (K = 1).
  sample: Function sample(fit_bundle, newdata, n_samp, ...) drawing samples
    from the implied conditional density (assumes K = 1).

Data requirements

The runner expects train_set and newdata in long hazard format, including:
  - a binary outcome column in_bin,
  - a time-bin column bin_id,
  - covariates referenced in rhs_list,
  - an optional weight column wts.

newdata passed to sample() must additionally include:
  - obs_id,
  - bin_lower,
  - bin_upper.
}
\description{
Constructs a runner (learner adapter) compatible with the
run_grid_setting() / summarize_and_select() workflow used in dsl_densify.
The runner fits penalized logistic regression models via glmnet::glmnet()
on long-format discrete-time hazard data with binary outcome in_bin.
}
\details{
Tuning is performed over a grid defined by:
  - multiple RHS model specifications (rhs_list),
  - elastic net mixing parameters (alpha_grid),
  - a fixed penalty grid (lambda_grid).

Each fitted model estimates per-bin discrete-time hazards
  P(T in bin_j | T >= bin_j, W)
under the discrete-time hazard likelihood induced by the long-data
construction used in dsl_densify.

Spline handling

Natural spline terms may be specified directly in the RHS using ns() or
splines::ns(), subject to the following restrictions:
  - Only ns(<symbol>, df = ...) is supported; the first argument must be a
    bare variable name.
  - splines::ns() is accepted but internally rewritten to ns().
  - Knot locations and boundary knots are computed once on the training
    data within each fold and then frozen.

Frozen spline bases are enforced by evaluating model.matrix() in an
environment where ns() is replaced by a wrapper that injects the stored
knot information. This ensures consistent spline bases within each fold
and between training, validation, and sampling.

Numeric-only requirement

This runner is intended for use with numeric predictors only. All variables
referenced in rhs_list (including bin_id and all covariates in W) must
already be numeric. Factors, characters, and ordered factors are not
supported and are not coerced internally.

Tuning grid and prediction layout

The internal tune_grid is ordered such that RHS varies first, then alpha,
then lambda (lambda varies fastest). During cross-validation, predict()
returns an n_long x K matrix of predicted hazards, where
  K = length(rhs_list) * length(alpha_grid) * length(lambda_grid),
with columns aligned to tune_grid (and .tune).

Prediction delegates to an internal predict_hazards() helper so that
prediction and sampling always use identical hazard estimates.

Sampling from the fitted hazard model

The runner provides a sample() method that generates draws
  A* ~ f_hat(Â· | W)
from the implied conditional density under the discrete-time hazard
representation.

Sampling assumes the fit_bundle contains exactly one fitted model
(length(fit_bundle$fits) == 1). This is the intended usage after model
selection, for example via select_fit_tune() or fit_one().

IMPORTANT: The sample() method expects newdata in long hazard format.
Expansion of wide W to long form (repeating rows across all bins and
attaching bin_lower and bin_upper) is handled upstream by
sample.dsldensify(). The runner itself never constructs hazard grids.

For each subject, sampling proceeds by:
  - predicting hazards h_j for all bins,
  - computing implied bin masses
      p_j = h_j * prod_{l < j} (1 - h_l),
  - normalizing the masses to sum to one,
  - sampling a bin index according to p_j,
  - sampling uniformly within the selected bin.

If the total mass is non-finite or non-positive for any subject, a single
warning is issued and sampling for those subjects falls back to uniform
sampling over bins.

Lightweight fit objects

When strip_fit = TRUE, each fitted (rhs, alpha) block is reduced to a
minimal representation sufficient for prediction:
  - an intercept vector a0 of length length(lambda_grid),
  - a sparse coefficient matrix beta (Matrix::dgCMatrix), dimensions p x L,
  - the training column names x_cols.

This saves memory relative to storing full glmnet objects.
}
\examples{
rhs_list <- list(
  ~ W1 + W2 + splines::ns(bin_id, df = 4),
  ~ (W1 + W2) * splines::ns(bin_id, df = 4)
)

runner <- make_glmnet_runner(
  rhs_list = rhs_list,
  alpha_grid = c(0.5, 1),
  lambda_grid = exp(seq(log(1e-4), log(10), length.out = 50)),
  strip_fit = TRUE
)

}

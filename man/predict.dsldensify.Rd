% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsldensify.R
\name{predict.dsldensify}
\alias{predict.dsldensify}
\title{Predict conditional densities from a fitted dsldensify object}
\usage{
\method{predict}{dsldensify}(
  object,
  A,
  W,
  type = c("full", "cv"),
  fold_id = NULL,
  trim_predict = TRUE,
  eps = 1e-12,
  ...
)
}
\arguments{
\item{object}{Fitted \code{"dsldensify"} object returned by \code{dsldensify()}.}

\item{A}{Numeric vector of values at which to evaluate the conditional density.
Must have the same length as \code{W} (number of rows).}

\item{W}{Covariate values at which to condition the density. May be a vector,
matrix, \code{data.frame}, or \code{data.table}. If \code{W} has multiple
rows, a density value is returned for each row paired with the corresponding
element of \code{A}.}

\item{type}{Character string indicating which fitted object to use:
\code{"full"} uses the full-data refit stored in \code{object$full_fit};
\code{"cv"} uses fold-specific fits stored in \code{object$cv_fit}.}

\item{fold_id}{Optional integer vector of fold assignments used when
\code{type = "cv"}. Must have length \code{length(A)} and take values in
\code{1, ..., V}, where \code{V = length(object$cv_fit)}. Each entry indicates
which fold-specific fit should be used for the corresponding observation.}

\item{trim_predict}{Logical. When the selected model is hazard-based and
\code{TRUE}, replaces predicted densities for \code{A} values outside the
training support with a small positive value. This is intended to avoid
returning exactly zero density due to extrapolation beyond the bin range.}

\item{eps}{Small positive constant used to bound probabilities and densities
away from zero during computation. For direct learners, it is passed to the
runner's \code{log_density} method when supported.}

\item{...}{Additional arguments passed to the selected learner runner's
prediction methods (\code{predict} for hazard learners; \code{log_density}
for direct learners).}
}
\value{
A numeric vector of length \code{length(A)} containing estimated
  conditional densities evaluated at each paired \code{(A_i, W_i)}.
}
\description{
Computes conditional density estimates \eqn{f(A \mid W)} from an object
returned by \code{dsldensify()}. Predictions can be produced either from a
full-data refit (\code{type = "full"}) or using fold-specific fits for
cross-validated prediction (\code{type = "cv"}).
}
\details{
If the selected model is a direct density learner, densities are obtained by
evaluating the learner's conditional log-density and exponentiating. If the
selected model is a hazard-based learner, new data are expanded to long-format
hazards using the stored bin definitions; predicted hazards are converted to
bin probabilities and then to a continuous density by dividing by bin widths.


For hazard-based models, let \eqn{\lambda_j(w)} denote the discrete hazard of
falling in bin \eqn{j} given \eqn{W = w}, and let \eqn{\Delta_j} denote the
bin width. The implied bin probability mass is
\deqn{
  p_j(w) = \lambda_j(w) \prod_{k < j} \left\{1 - \lambda_k(w)\right\},
}
and the corresponding density estimate for \eqn{A} in bin \eqn{j} is
\deqn{
  \hat f(a \mid w) = p_j(w) / \Delta_j.
}
This function constructs the necessary long-format data at prediction time
using \code{object$breaks} and \code{object$bin_length}, obtains hazard
predictions from the selected runner, converts them to bin mass, and then
scales by the bin widths.

When \code{type = "cv"}, predictions are computed using the fold-specific fit
indexed by \code{fold_id}. This is useful for cross-fitted workflows (for
example, in double machine learning), where each observation must be predicted
using a model that did not train on that observation.
}
\examples{
set.seed(1)

n <- 80
W <- data.frame(x1 = rnorm(n), x2 = rnorm(n))
A <- 0.6 * W$x1 - 0.2 * W$x2 + rnorm(n)

gaussian_runner <- make_gaussian_homosked_runner(rhs_list = "~ x1 + x2")

fit <- dsldensify(
  A = A,
  W = W,
  hazard_learners = NULL,
  direct_learners = list(gaussian = gaussian_runner),
  cv_folds = 3,
  return_cv_fits = TRUE,
  refit_dsl_full_data = TRUE
)

# Full-data prediction
A_new <- c(0, 0)
W_new <- data.frame(x1 = c(0, 1), x2 = c(0, 0))
predict(fit, A = A_new, W = W_new, type = "full")

# Cross-validated prediction (requires fold_id)
fold_id <- fit$id_fold
predict(fit, A = A, W = W, type = "cv", fold_id = fold_id)

}
\seealso{
\code{\link{dsldensify}}
}

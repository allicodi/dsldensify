% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runner_glm.R
\name{make_glm_runner}
\alias{make_glm_runner}
\title{Create a GLM runner for discrete-time hazard modeling with frozen spline bases}
\usage{
make_glm_runner(rhs_list, use_weights_col = TRUE, strip_fit = TRUE, ...)
}
\arguments{
\item{rhs_list}{A list of RHS specifications, either as one-sided formulas
(for example, ~ W1 + ns(bin_id, df = 5)) or as character strings
(for example, "W1 + splines::ns(bin_id, df = 5)").}

\item{use_weights_col}{Logical. If TRUE and the training data contain a
column named wts, it is passed as case weights to stats::glm.fit().}

\item{strip_fit}{Logical. If TRUE (default), store a lightweight
coefficient-based representation of each fitted model. If FALSE, store
full glm objects.}

\item{...}{Additional arguments forwarded to stats::glm.fit() when
strip_fit = TRUE and to stats::glm() when strip_fit = FALSE.}
}
\value{
A named list (runner) with the following elements:
  method: Character string "glm".
  tune_grid: Data frame describing the tuning grid, including .tune and rhs.
  fit: Function fit(train_set, ...) returning a fit bundle.
  predict: Function predict(fit_bundle, newdata, ...) returning an
    n_long x K matrix of predicted hazards.
  fit_one: Function fit_one(train_set, tune, ...) fitting only the selected
    tuning index.
  sample: Function sample(fit_bundle, newdata, n_samp, ...) drawing samples
    from the implied conditional density (assumes K = 1).

Data requirements

The runner expects train_set and newdata in long hazard format, including:
  - a binary outcome column in_bin,
  - a time-bin column bin_id,
  - a subject identifier column obs_id,
  - covariates referenced in rhs_list,
  - an optional weight column wts.

newdata passed to sample() must additionally include bin_lower and bin_upper.
}
\description{
Constructs a runner (learner adapter) compatible with the
run_grid_setting() / summarize_and_select() workflow used in dsl_densify.
The runner fits one or more logistic regression models via stats::glm.fit()
on long-format discrete-time hazard data with binary outcome in_bin.
}
\details{
Tuning is performed over a list of RHS model specifications (rhs_list);
exactly one model is fit per RHS. Each fitted model estimates per-bin
discrete-time hazards
  P(T in bin_j | T >= bin_j, W)
using a logistic likelihood, which is equivalent to maximizing the
discrete-time hazard likelihood under the long-data construction used
by dsl_densify.

This runner closely mirrors the conventions of the xgboost hazard runner:
prediction and sampling share a common hazard-scoring path, sampling
assumes post-selection fits (K = 1), and sampling operates exclusively
on long hazard data constructed upstream.

Spline handling

Natural spline terms may be specified directly in the RHS using ns() or
splines::ns(), subject to the following restrictions:
  - Only ns(<symbol>, df = ...) is supported; the first argument must be
    a bare variable name.
  - splines::ns() is accepted but internally rewritten to ns().
  - Knot locations and boundary knots are computed once on the training
    data within each fold and then frozen.

Frozen spline bases are enforced at prediction and sampling time by
evaluating model.matrix() in an environment where ns() is replaced by a
wrapper that injects the stored knot information. This guarantees
consistency of spline bases within each fold and between training,
validation, and sampling.

Numeric-only requirement

This runner is intended for use with numeric predictors only. All variables
referenced in rhs_list (including bin_id and all covariates in W) must
already be numeric. Factors, characters, and ordered factors are not
supported and are not coerced internally.

Tuning grid and prediction layout

The runner constructs a tune_grid with one row per RHS specification and
columns .tune and rhs. During cross-validation, predict() returns an
n_long x K matrix of predicted hazards, where K = length(rhs_list), with
columns aligned to the ordering of tune_grid.

Prediction delegates to an internal predict_hazards() helper so that
prediction and sampling always use identical hazard estimates.

Sampling from the fitted hazard model

The runner provides a sample() method that generates draws
  A* ~ f_hat(Â· | W)
from the implied conditional density under the discrete-time hazard
representation.

Sampling assumes the fit_bundle contains exactly one fitted model
(length(fit_bundle$fits) == 1). This is the intended usage after model
selection, for example via select_fit_tune() or fit_one().

IMPORTANT: The sample() method expects newdata in long hazard format.
Expansion of wide W to long form (repeating rows across all bins and
attaching bin_lower and bin_upper) is handled upstream by
sample.dsldensify(). The runner itself never constructs hazard grids.

For each subject, sampling proceeds by:
  - predicting hazards h_j for all bins,
  - computing implied bin masses
      p_j = h_j * prod_{l < j} (1 - h_l),
  - normalizing the masses to sum to one,
  - sampling a bin index according to p_j,
  - sampling uniformly within the selected bin.

If the total mass is non-finite or non-positive for any subject, a single
warning is issued and sampling for those subjects falls back to uniform
sampling over bins.

Lightweight fit objects

When strip_fit = TRUE, each fitted model is reduced to a minimal
representation sufficient for prediction and sampling:
  - a numeric coefficient vector aligned to frozen design columns,
  - the inverse link function (linkinv),
  - the training column names.

When strip_fit = FALSE, full glm objects are stored; however, prediction
and sampling still use frozen design matrices and extracted coefficients
to preserve spline consistency.
}
\examples{
rhs_list <- list(
  ~ W1 + W2 + splines::ns(bin_id, df = 4),
  ~ (W1 + W2) * splines::ns(bin_id, df = 4)
)

runner <- make_glm_runner(
  rhs_list = rhs_list,
  use_weights_col = TRUE,
  strip_fit = TRUE
)

}

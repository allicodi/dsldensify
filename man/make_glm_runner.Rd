% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runner_glm.R
\name{make_glm_runner}
\alias{make_glm_runner}
\title{Create a GLM runner for discrete-time hazard modeling (with frozen spline bases)}
\usage{
make_glm_runner(rhs_list, use_weights_col = TRUE, strip_fit = TRUE, ...)
}
\arguments{
\item{rhs_list}{A list of RHS specifications, either:
\itemize{
  \item one-sided formulas such as \code{~ W1 + ns(bin_id, df = 5)}, or
  \item character strings such as \code{"W1 + splines::ns(bin_id, df = 5)"}.
}
These RHS are used to construct \code{in_bin ~ <rhs>} internally.}

\item{use_weights_col}{Logical. If \code{TRUE} and the training data contain a
column named \code{wts}, it is passed as \code{weights = ...} to
\code{stats::glm.fit()}. Otherwise, fitting is unweighted.}

\item{strip_fit}{Logical. If \code{TRUE} (default), store a lightweight fit
representation (coefficients + link inverse only) rather than a full \code{glm}
object. If \code{FALSE}, models are fit and stored as full \code{glm} objects.}

\item{...}{Additional arguments forwarded to \code{stats::glm.fit()} when
\code{strip_fit = TRUE}, and to \code{stats::glm()} when \code{strip_fit = FALSE}.}
}
\value{
A named list (runner) with elements:
\describe{
  \item{method}{Character string \code{"glm"}.}
  \item{tune_grid}{Data frame with columns \code{.tune} and \code{rhs}.}
  \item{fit}{Function \code{fit(train_set, ...)} returning a fit bundle. The
  fit bundle contains \code{fits}, a list of length \code{K} of fitted models
  (stripped or full), and \code{design_specs} that freeze spline knots/columns
  for each RHS.}
  \item{predict}{Function \code{predict(fit_bundle, newdata, ...)} returning an
  \code{n_long x K} matrix of hazard predictions.}
  \item{fit_one}{Function \code{fit_one(train_set, tune, ...)} fitting only the
  selected tuning index and returning a minimal fit bundle compatible with
  \code{predict()}.}
}
}
\description{
Constructs a **runner** (learner adapter) compatible with the
\code{run_grid_setting()} / \code{summarize_and_select()} workflow used in
dsl_densify. The runner fits one or more logistic regression models via
\code{stats::glm.fit()} on long-format discrete-time hazard data with binary
outcome \code{in_bin}. Tuning is performed over a list of RHS model
specifications (\code{rhs_list}); one model is fit per RHS.

This GLM runner supports natural spline terms specified directly in the RHS
using \code{ns()} or \code{splines::ns()}, under a restricted but reproducible
spline policy that avoids storing large formula environments:
\itemize{
  \item Only \code{ns(<symbol>, df = ...)} is supported (the first argument must
        be a bare variable name).
  \item \code{splines::ns()} is accepted but internally rewritten to \code{ns()}.
  \item Knot locations are computed on the training data and then frozen for
        prediction by evaluating \code{model.matrix()} in an environment where
        \code{ns()} is replaced by a wrapper that injects stored knots and
        boundary knots. This ensures consistent spline bases within each
        fold and between training and validation data.
}
}
\details{
## Data requirements
The runner expects \code{train_set} and \code{newdata} in the **long hazard
format** produced by \code{format_long_hazards()}, including:
\itemize{
  \item a binary outcome column \code{in_bin},
  \item covariates referenced in \code{rhs_list},
  \item an optional \code{wts} column of observation weights (repeated on long rows).
}

## Spline handling
Spline knots (and boundary knots) are computed once per fold (inside \code{fit()})
using the training data and stored in \code{design_specs}. Prediction uses the
stored spline specifications to ensure consistent spline bases across training
and validation data within each fold.

## Interactions
Interactions between spline terms and other covariates (for example,
\code{W1 * ns(bin_id, df = 5)}) are supported and handled via
\code{model.matrix()}. Nested spline constructs are not supported.
}
\section{Numeric-only requirement}{

The design matrix is constructed using \code{stats::model.matrix()}.
To ensure stable feature definitions across folds and avoid factor-level
bookkeeping, this runner is intended for use with **numeric predictors only**
(including \code{bin_id} and all covariates in \code{W}). RHS formulas should
not include factors, characters, or ordered factors. This function does not
coerce variables to numeric; it assumes inputs are already in numeric form.
}

\section{Tuning and prediction layout}{

The runner creates a \code{tune_grid} with one row per RHS, with columns
\code{.tune} and \code{rhs}. During cross-validation, \code{predict()} returns
an \code{n_long x K} matrix of predicted hazards, where \code{K = length(rhs_list)}.
Columns are aligned to the runner's \code{tune_grid} ordering.
}

\section{Lightweight fit objects}{

When \code{strip_fit = TRUE}, each fitted GLM is reduced to a minimal
representation sufficient for prediction:
\itemize{
  \item a numeric coefficient vector aligned to the frozen design columns
        \code{x_cols},
  \item the inverse link function \code{linkinv} for mapping linear predictors
        to hazard probabilities,
  \item the training column names \code{x_cols}.
}
This can substantially reduce memory usage when storing fold-specific CV fits.
}

\examples{
rhs_list <- list(
  ~ W1 + W2 + splines::ns(bin_id, df = 4),
  ~ (W1 + W2) * splines::ns(bin_id, df = 4)
)

runner <- make_glm_runner(
  rhs_list = rhs_list,
  use_weights_col = TRUE,
  strip_fit = TRUE
)

}

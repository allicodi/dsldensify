% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runner_direct_quantreg.R
\name{make_quantreg_direct_runner}
\alias{make_quantreg_direct_runner}
\title{Create a quantile-based direct density runner}
\usage{
make_quantreg_direct_runner(
  rhs_list,
  n_quantiles_grid = c(50L, 100L),
  p_min = 0.01,
  p_max = 0.99,
  smoother_grid = c("diff", "spline"),
  spline_df_grid = c(7L),
  local_span_grid = c(0.25),
  enforce_monotone = TRUE,
  use_weights_col = TRUE,
  strip_fit = TRUE,
  eps = 1e-12,
  ...
)
}
\arguments{
\item{rhs_list}{A list of RHS specifications, either one-sided formulas
(for example, ~ x1 + x2) or character strings (for example, "x1 + x2").
These RHS are used to build the mean structure for the conditional quantile
function.}

\item{n_quantiles_grid}{Integer vector giving the number of quantile levels to
use in the p grid (for example, 50, 100, 200).}

\item{p_min, p_max}{Endpoints for the internal p grid. The grid is
seq(p_min, p_max, length.out = n_quantiles). Defaults avoid exactly 0/1.}

\item{smoother_grid}{Character vector specifying how to obtain dQ/dp from the
fitted quantile curve:
- "diff": finite differences on the p grid
- "spline": smoothing spline in p for each observation
- "local": local linear regression in p for each observation}

\item{spline_df_grid}{Integer vector of degrees of freedom for smoother_grid = "spline".}

\item{local_span_grid}{Numeric vector of spans for smoother_grid = "local".}

\item{enforce_monotone}{Logical. If TRUE, apply a rearrangement step to ensure
the predicted quantile function is nondecreasing in p for each observation.}

\item{use_weights_col}{Logical. If TRUE and the training data contain a column
named wts, it is passed to the quantile fitting routine as weights when
supported.}

\item{strip_fit}{Logical. If TRUE, store a lightweight fit representation.}

\item{eps}{Small positive constant used to bound densities away from zero and
log-densities away from -Inf, and to clip p and derivatives.}

\item{...}{Additional arguments passed to the underlying quantile learner.
This sketch uses quantreg::rq() by default.}
}
\value{
A named list (runner) with elements:
  method: Character string "quantile".
  tune_grid: Data frame describing the tuning grid, including .tune.
  fit: Function fit(train_set, ...) returning a fit bundle.
  log_density: Function log_density(fit_bundle, newdata, ...) returning an
    n x K matrix of log-densities.
  density: Function density(fit_bundle, newdata, ...) returning densities.
  fit_one: Function fit_one(train_set, tune, ...) fitting only the selected tuning index.
  select_fit: Function select_fit(fit_bundle, tune) extracting a single tuning configuration.
  sample: Function sample(fit_bundle, newdata, n_samp, ...) drawing samples
    (assumes length(fit_bundle$fits) == 1).

Data requirements

The runner expects train_set and newdata in wide format containing:
  - a numeric outcome column A,
  - covariates referenced in rhs_list,
  - an optional weight column wts.
}
\description{
Constructs a runner (learner adapter) compatible with the dsldensify() /
summarize_and_select() workflow for direct conditional density estimation of a
continuous outcome A given covariates W using an estimated conditional quantile
function Q(p | W).
}
\details{
This runner fits conditional quantile models on a fixed grid of probability
levels p in (0, 1). The implied conditional density is recovered by
differentiating the fitted quantile function in p and applying the identity
  f(a | W) = 1 / (dQ(p | W) / dp) evaluated at p satisfying Q(p | W) = a.

Sampling is straightforward: draw p ~ Uniform(0, 1) and return A* = Q(p | W).

The runner is designed to be lightweight and robust in cross-validation:
  - quantile levels are fixed per tuning row,
  - monotonicity in p can be enforced by rearrangement,
  - density evaluation uses either finite differences or a p-smoother.

Numeric-only requirement

Covariates referenced in RHS specifications are assumed numeric. Factor handling
is not supported.

Tuning grid and prediction layout

The internal tune_grid is the Cartesian product of:
  - rhs (from rhs_list),
  - n_quantiles (from n_quantiles_grid),
  - smoother (from smoother_grid),
  - bandwidth / df parameters for the chosen smoother (when applicable).

Each row of tune_grid corresponds to exactly one fitted quantile learner.
During cross-validation, log_density() returns an n x K matrix of log-densities
aligned to .tune.

Sampling from the fitted model

The runner provides a sample() method that generates draws A* ~ f_hat(Â· | W).
Sampling assumes the fit_bundle contains exactly one tuned fit
(length(fit_bundle$fits) == 1). It expects newdata in wide format containing W
only and returns an nrow(newdata) x n_samp matrix.
}
\examples{
runner <- make_quantile_runner(
  rhs_list = list(~ x1 + x2),
  n_quantiles_grid = c(50L, 100L),
  smoother_grid = c("diff", "spline"),
  spline_df_grid = c(7L, 11L)
)

}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{format_long_hazards}
\alias{format_long_hazards}
\title{Create long-format discrete-time hazard data for density estimation}
\usage{
format_long_hazards(
  A,
  W,
  wts = rep(1, length(A)),
  grid_type = c("equal_range", "equal_mass"),
  n_bins = NULL,
  breaks = NULL,
  quantile_type = 8L
)
}
\arguments{
\item{A}{Numeric vector representing outcome/exposure being discretized into bins.}

\item{W}{Baseline covariates. Either a vector of length \code{n} or a
2D object (matrix/data.frame). If \code{W} has no column
names, columns are named \code{W_1, W_2, ...}.}

\item{wts}{Numeric vector of length \code{n} giving non-negative observation-level weights.}

\item{grid_type}{Character. One of \code{"equal_range"} or \code{"equal_mass"}.
Only used when \code{n_bins} is provided.}

\item{n_bins}{Integer number of bins (used when \code{breaks} is \code{NULL}).}

\item{breaks}{Optional numeric vector of full bin endpoints of length. If provided, \code{n_bins} 
is ignored and bins are defined by these endpoints.}

\item{quantile_type}{Integer passed to \code{stats::quantile(type = ...)} when
\code{grid_type = "equal_mass"}.}
}
\value{
A list with components:
\describe{
  \item{data}{A \code{data.table} in long format with columns \code{obs_id},
    \code{in_bin}, \code{bin_id}, covariates from \code{W}, and \code{wts}.}
  \item{breaks}{Left endpoints of bins (numeric vector length \code{J}) when
    \code{n_bins} is used; \code{NULL} when \code{breaks} is supplied.}
  \item{bin_length}{Bin widths (numeric vector length \code{J}) when
    \code{n_bins} is used; \code{NULL} when \code{breaks} is supplied.}
}
}
\description{
Converts observation-level data \code{(A_i, W_i, wt_i)} into a long-format
representation suitable for fitting a discrete-time hazard model.
For each observation \code{i}, the function creates one row for each bin
\code{j = 1, ..., bin_id[i]}, where \code{bin_id[i]} is the bin into which 
\code{A_i} falls. The function defines an indicator \code{in_bin} that equals
1 on the terminal bin and 0 on all prior bins. This supports a
discrete-time hazard regression for \code{P(A in bin_j | A >= left_j, W)} and
subsequent mapping of hazards to bin masses (and, with bin-width scaling, to
a continuous density approximation).
}
\details{
## Grid/bins
The binning grid may be provided directly via \code{breaks} or constructed
from \code{A} using \code{n_bins} and \code{grid_type}:

* If \code{breaks} is provided, it must be a numeric vector specifying the full bin 
  endpoints. Observation bin membership is computed via \code{findInterval(A, 
  breaks, rightmost.closed = TRUE, all.inside = TRUE)}. Values of \code{A} outside 
  the range of \code{breaks} are clipped to the boundary bins due to \code{all.inside = TRUE}.

* If \code{n_bins} is provided, the function constructs \code{J = n_bins}
  bins over the observed range of \code{A}. For \code{grid_type = "equal_range"}, bins are
  equally spaced over \code{[min(A), max(A)]}. For \code{grid_type = "equal_mass"}, bin
  endpoints are empirical quantiles of \code{A} using \code{quantile_type}.
  When ties in \code{A} cause duplicated quantile breakpoints, duplicates are
  dropped and the effective number of bins may be smaller than requested.

If using \code{n_bins}, the function returns:
\itemize{
  \item \code{breaks}: the left endpoints
  \item \code{bin_length}: the bin widths
}

## Long-format construction
Let \code{bin_id[i]} be the terminal bin index for observation \code{i}. The
output data has \code{sum_i bin_id[i]} rows, with:
\itemize{
  \item \code{obs_id}: original observation index \code{i}
  \item \code{bin_id}: bin index \code{j} running from 1 to \code{bin_id[i]}
  \item \code{in_bin}: indicator equal to 1 if \code{j == bin_id[i]}, else 0
  \item Baseline covariates \code{W} repeated across the long rows for \code{i}
  \item \code{wts}: observation-level weights repeated across the long rows
}

## Relationship to densities and bin widths
Downstream, the fitted hazard model can be mapped to a bin mass
\code{P(A in bin_j | W)} for each observation. To interpret this as an
approximation to a continuous density at the observed \code{A_i}, one divides
the terminal-bin mass by the terminal-bin width.
}
\examples{
\dontrun{
set.seed(1)
n <- 10
A <- rexp(n)
W <- data.frame(w1 = rnorm(n), w2 = rbinom(n, 1, 0.5))

# Equal-width bins
out1 <- format_long_hazards(A, W, n_bins = 10, grid_type = "equal_range")

# Equal-mass (quantile) bins
out2 <- format_long_hazards(A, W, n_bins = 10, grid_type = "equal_mass")

# Recreate the same endpoints using breaks
breaks_full <- c(out1$breaks, tail(out1$breaks, 1) + tail(out1$bin_length, 1))
out3 <- format_long_hazards(A, W, breaks = breaks_full)
}

}

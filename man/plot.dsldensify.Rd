% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{plot.dsldensify}
\alias{plot.dsldensify}
\title{Plot conditional or implied marginal density estimates from a dsldensify fit}
\usage{
\method{plot}{dsldensify}(
  x,
  W_grid,
  n_A = 200L,
  A_range = NULL,
  type = c("full", "cv"),
  cv_fold = NULL,
  mode = c("conditional", "marginal"),
  trim_predict = TRUE,
  eps = 1e-12,
  xlab = "A",
  ylab = "Density",
  main = NULL,
  lty = NULL,
  legend = TRUE,
  legend_pos = "topright",
  add = FALSE,
  component = c("auto", "combined", "hurdle", "positive"),
  annotate = TRUE,
  atom_lty = 1,
  atom_scale = c("auto", "fixed"),
  atom_scale_fixed = NULL,
  predict_args = list(),
  plot_args = list()
)
}
\arguments{
\item{x}{Fitted \code{"dsldensify"} object returned by \code{dsldensify()}.}

\item{W_grid}{A \code{data.frame} or \code{data.table} giving covariate
profiles at which to evaluate the density. Each row is treated as a distinct
covariate profile \eqn{w_j}. Must contain columns matching those used to fit
the selected learner.}

\item{n_A}{Integer giving the number of grid points used to evaluate \code{A}.}

\item{A_range}{Optional numeric vector of length 2 specifying the range of
\code{A} values over which to plot. If \code{NULL} and the selected model is
hazard-based, the training bin support is used. Otherwise defaults to
\code{c(-3, 3)}.}

\item{type}{Character string indicating which fit to use for prediction:
\code{"full"} uses \code{x$full_fit}; \code{"cv"} uses fold-specific fits and
requires \code{cv_fold}.}

\item{cv_fold}{Integer specifying which cross-validation fold fit to use when
\code{type = "cv"}. For plotting, a single fold is used for all evaluations.}

\item{mode}{Character string specifying the plotting mode. \code{"conditional"}
plots a curve for each row of \code{W_grid}. \code{"marginal"} plots the
average curve across rows of \code{W_grid}.}

\item{trim_predict}{Logical passed to \code{predict.dsldensify()} controlling
whether to trim hazard-based predictions outside the training support.}

\item{eps}{Small positive constant passed to \code{predict.dsldensify()} and,
for direct learners, to the underlying runner when supported.}

\item{xlab}{Character string giving the x-axis label.}

\item{ylab}{Character string giving the y-axis label.}

\item{main}{Optional plot title. If \code{NULL} and \code{add = FALSE}, a
default title is constructed from \code{type} and \code{mode}.}

\item{lty}{Optional vector of line types used for conditional curves. Recycled
to match \code{nrow(W_grid)}.}

\item{legend}{Logical indicating whether to draw a legend in conditional mode
when \code{nrow(W_grid) > 1}.}

\item{legend_pos}{Legend position passed to \code{graphics::legend()}.}

\item{add}{Logical. If \code{FALSE}, a new plot is created. If \code{TRUE},
curves are added to the current plot using \code{graphics::matlines()} (for
conditional mode) or \code{graphics::lines()} (for marginal mode).}

\item{predict_args}{Optional named list of additional arguments passed to
\code{predict.dsldensify()}.}

\item{plot_args}{Optional named list of additional arguments passed to the
underlying plotting function. When \code{mode = "conditional"} and
\code{add = FALSE}, arguments are passed to \code{graphics::matplot()}.
When \code{mode = "marginal"} and \code{add = FALSE}, arguments are passed
to \code{graphics::plot()}.}
}
\value{
Invisibly returns a list with components:
\describe{
  \item{A}{Numeric vector of grid values at which the density was evaluated.}
  \item{dens}{In conditional mode, a matrix of densities with
    \code{length(A)} rows and \code{nrow(W_grid)} columns. In marginal mode, a
    numeric vector of length \code{length(A)} giving the averaged density.}
  \item{dens_by_W}{In marginal mode, the full matrix of per-row conditional
    densities used to form the average.}
}
}
\description{
Plots density estimates implied by an object returned by \code{dsldensify()}.
The function evaluates \eqn{f(A \mid W)} over a grid of \code{A} values for one
or more covariate profiles supplied in \code{W_grid}. Two plotting modes are
supported:
\enumerate{
  \item \code{"conditional"}: plot \eqn{f(A \mid W = w_j)} for each row
    \eqn{w_j} of \code{W_grid}.
  \item \code{"marginal"}: compute \eqn{f(A \mid W = w_j)} for each row and
    plot their average over rows of \code{W_grid}, yielding an implied marginal
    density over \code{A} for that empirical distribution of \code{W}.
}
}
\details{
Predictions are obtained by calling \code{predict.dsldensify()}, either using
the stored full-data fit (\code{type = "full"}) or using a single specified
cross-validation fold fit (\code{type = "cv"} with \code{cv_fold}).
}
\examples{
set.seed(1)
n <- 80
W <- data.frame(x1 = rnorm(n), x2 = rnorm(n))
A <- 0.6 * W$x1 - 0.2 * W$x2 + rnorm(n)

gaussian_runner <- make_gaussian_homosked_runner(rhs_list = "~ x1 + x2")

fit <- dsldensify(
  A = A,
  W = W,
  hazard_learners = NULL,
  direct_learners = list(gaussian = gaussian_runner),
  cv_folds = 3,
  return_cv_fits = TRUE,
  refit_dsl_full_data = TRUE
)

W_grid <- data.frame(
  x1 = c(0, 1),
  x2 = c(0, 0)
)

plot(fit, W_grid, mode = "conditional", type = "full")
plot(fit, W_grid, mode = "marginal", type = "full")

}
\seealso{
\code{\link{dsldensify}}, \code{\link{predict.dsldensify}}
}
